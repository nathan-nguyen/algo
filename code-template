// Classic way

Arrays.sort(points, new Comparator<int[]>(){
	@Override public int compare(int[] o1, int[] o2){
		// Convert to (long) to avoid overflow
		if (o1[0] == o2[0]) return 0;
		return (o1[0] > o2[0]) ? 1 : -1;
	}
});

// In Java 8

Integer[] a = new Integer[100];
int[] condition = new int[100];

Arrays.sort(a, (x, y) -> condition[x] - condition[y]);

// Primitive type cannot be sorted this way, need to convert to Object

int[][] a = new int[100][2];

Arrays.sort(a, (x, y) -> x[0] - y[0]);

Arrays.sort(a, (x, y) -> {
	if (x[0] == y[0]) return x[1] - y[1];
	else return x[0] - y[0];
});

--------------------

for (int key : frequencyMap.keySet()) {
	int frequency = frequencyMap.get(key);
	if (bucket[frequency] == null) {
		bucket[frequency] = new ArrayList<>();
	}
	bucket[frequency].add(key);
}

--------------------

public int searchInsert(int[] A, int target) {
	int low = 0, high = A.length-1;
	while(low<=high){
		int mid = (low+high)/2;
		if(A[mid] == target) return mid;
		else if(A[mid] > target) high = mid-1;
		else low = mid+1;
	}
	return low;
}

--------------------

PriorityQueue<Integer> pq = new PriorityQueue<>();
for (int i = 0; i < nums.length; ++i){
	pq.offer(nums[i]);
	if (pq.size() > k) pq.poll();
}
return pq.peek();

--------------------

// String - REGEX match
int matches = (password.matches(".*[0-9].*")? 0 : 1) + (password.matches(".*[a-z].*") ? 0 : 1) + (password.matches(".*[A-Z].*") ? 0 : 1) + (password.matches(".*[!@#$%^&*()-+].*") ? 0 : 1);

--------------------

ArrayList<Integer> result = new ArrayList<>();
int[] resultArray = result.stream().mapToInt(i->i).toArray();

--------------------

Arrays.copyOfRange

--------------------

ListNode cur = head;
ListNode next = head;

while(next != null && next.next != null){
	cur = cur.next;
	next = next.next.next;
}

// 2: 0-1-null		-> 0-0|1-null
// 3: 0-1-2-null	-> 0-0|1-2
// 4: 0-1-2-3-null	-> 0-0|1-2|2-null

--------------------

Flip bit at poition k

n ^ (1 << k)

--------------------

